<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Harmonic Analyzer">
    <title>Harmonic Analyzer Pro - Trance Edition</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&family=JetBrains+Mono:wght@300;400;500&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #0a0e1a;
            --bg-secondary: #12182b;
            --bg-tertiary: #1a2235;
            --accent-primary: #00f0ff;
            --accent-secondary: #ff00ea;
            --accent-tertiary: #00ff88;
            --text-primary: #ffffff;
            --text-secondary: #8b95b8;
            --text-muted: #4a5578;
            --surface: rgba(26, 34, 53, 0.6);
            --surface-elevated: rgba(26, 34, 53, 0.9);
            --glow-cyan: rgba(0, 240, 255, 0.3);
            --glow-magenta: rgba(255, 0, 234, 0.3);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'JetBrains Mono', monospace;
            background: var(--bg-primary);
            min-height: 100vh;
            color: var(--text-primary);
            overflow-x: hidden;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 30%, var(--glow-cyan) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, var(--glow-magenta) 0%, transparent 50%);
            pointer-events: none;
            z-index: 0;
            opacity: 0.15;
        }

        .grain {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.03;
            pointer-events: none;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 400 400' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
            z-index: 1;
        }

        .container {
            position: relative;
            z-index: 2;
            max-width: 1400px;
            margin: 0 auto;
            padding: 40px 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 60px;
            animation: slideDown 0.8s cubic-bezier(0.16, 1, 0.3, 1);
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .logo {
            font-family: 'Orbitron', sans-serif;
            font-size: 48px;
            font-weight: 900;
            letter-spacing: -2px;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 8px;
            text-transform: uppercase;
            position: relative;
            display: inline-block;
        }

        .logo::after {
            content: '';
            position: absolute;
            bottom: -8px;
            left: 50%;
            transform: translateX(-50%);
            width: 60%;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--accent-primary), transparent);
        }

        .tagline {
            font-size: 13px;
            letter-spacing: 3px;
            color: var(--text-secondary);
            text-transform: uppercase;
            font-weight: 300;
        }

        .badge {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            background: var(--surface-elevated);
            border: 1px solid rgba(0, 240, 255, 0.3);
            padding: 6px 16px;
            border-radius: 20px;
            font-size: 11px;
            margin-top: 16px;
            color: var(--accent-primary);
            font-weight: 500;
            backdrop-filter: blur(10px);
        }

        .badge::before {
            content: '‚óè';
            animation: pulse-dot 2s ease-in-out infinite;
        }

        @keyframes pulse-dot {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(0.8); }
        }

        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        @media (max-width: 968px) {
            .grid {
                grid-template-columns: 1fr;
            }
        }

        .card {
            background: var(--surface);
            backdrop-filter: blur(20px);
            border-radius: 24px;
            border: 1px solid rgba(255, 255, 255, 0.05);
            padding: 32px;
            position: relative;
            overflow: hidden;
            animation: fadeInUp 0.6s cubic-bezier(0.16, 1, 0.3, 1) backwards;
        }

        .card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--accent-primary), transparent);
            opacity: 0.5;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .card:nth-child(1) { animation-delay: 0.1s; }
        .card:nth-child(2) { animation-delay: 0.2s; }
        .card:nth-child(3) { animation-delay: 0.3s; }

        .card-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 24px;
            color: var(--text-primary);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .control-panel {
            text-align: center;
        }

        .btn {
            font-family: 'JetBrains Mono', monospace;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            color: var(--bg-primary);
            border: none;
            padding: 20px 48px;
            font-size: 15px;
            font-weight: 700;
            border-radius: 50px;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 12px;
            transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
            box-shadow: 0 10px 40px rgba(0, 240, 255, 0.3);
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn::before {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(135deg, var(--accent-secondary), var(--accent-primary));
            opacity: 0;
            transition: opacity 0.3s;
        }

        .btn:hover::before {
            opacity: 1;
        }

        .btn span {
            position: relative;
            z-index: 1;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 15px 50px rgba(0, 240, 255, 0.5);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn.stop {
            background: linear-gradient(135deg, #ff0055, #ff4488);
            box-shadow: 0 10px 40px rgba(255, 0, 85, 0.3);
        }

        .btn.stop::before {
            background: linear-gradient(135deg, #ff4488, #ff0055);
        }

        .btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none;
        }

        .recording-status {
            margin-top: 24px;
            padding: 20px;
            background: rgba(0, 240, 255, 0.05);
            border: 1px solid rgba(0, 240, 255, 0.2);
            border-radius: 16px;
            display: none;
        }

        .recording-status.active {
            display: block;
            animation: fadeInUp 0.4s cubic-bezier(0.16, 1, 0.3, 1);
        }

        .rec-indicator {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            margin-bottom: 12px;
        }

        .rec-dot {
            width: 12px;
            height: 12px;
            background: #ff0055;
            border-radius: 50%;
            box-shadow: 0 0 20px rgba(255, 0, 85, 0.8);
            animation: pulse-rec 1.5s ease-in-out infinite;
        }

        @keyframes pulse-rec {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.3); opacity: 0.7; }
        }

        .rec-time {
            font-family: 'Orbitron', sans-serif;
            font-size: 24px;
            font-weight: 700;
            color: var(--accent-primary);
        }

        .rec-hint {
            font-size: 11px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .analyzing {
            text-align: center;
            padding: 40px;
            display: none;
        }

        .analyzing.active {
            display: block;
        }

        .spinner {
            width: 60px;
            height: 60px;
            margin: 0 auto 24px;
            border: 3px solid rgba(0, 240, 255, 0.1);
            border-top: 3px solid var(--accent-primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .analyzing-text {
            font-family: 'Orbitron', sans-serif;
            font-size: 16px;
            color: var(--accent-primary);
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .analyzing-step {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .results {
            display: none;
        }

        .results.active {
            display: block;
        }

        .metrics {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 32px;
        }

        .metric {
            background: var(--bg-secondary);
            border: 1px solid rgba(0, 240, 255, 0.1);
            border-radius: 20px;
            padding: 28px;
            position: relative;
            overflow: hidden;
            transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
        }

        .metric:hover {
            border-color: rgba(0, 240, 255, 0.3);
            transform: translateY(-2px);
        }

        .metric::after {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 100px;
            height: 100px;
            background: radial-gradient(circle, var(--glow-cyan) 0%, transparent 70%);
            opacity: 0.1;
            pointer-events: none;
        }

        .metric-label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: var(--text-muted);
            margin-bottom: 12px;
            font-weight: 500;
        }

        .metric-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 48px;
            font-weight: 900;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-tertiary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            line-height: 1;
            margin-bottom: 8px;
        }

        .metric-sub {
            font-size: 11px;
            color: var(--text-secondary);
            min-height: 16px;
        }

        .confidence-bar {
            margin-top: 16px;
            height: 4px;
            background: rgba(0, 240, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
            position: relative;
        }

        .confidence-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-primary), var(--accent-tertiary));
            border-radius: 2px;
            transition: width 1s cubic-bezier(0.16, 1, 0.3, 1);
            box-shadow: 0 0 10px var(--accent-primary);
        }

        .confidence-text {
            font-size: 10px;
            color: var(--text-muted);
            margin-top: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .camelot-section {
            margin: 32px 0;
        }

        .camelot-title {
            text-align: center;
            font-family: 'Orbitron', sans-serif;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: var(--text-secondary);
            margin-bottom: 24px;
        }

        .wheel-container {
            position: relative;
            width: 320px;
            height: 320px;
            margin: 0 auto;
        }

        .wheel-svg {
            width: 100%;
            height: 100%;
            filter: drop-shadow(0 10px 40px rgba(0, 240, 255, 0.2));
        }

        .current-position {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            color: var(--bg-primary);
            width: 100px;
            height: 100px;
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            box-shadow: 0 10px 40px rgba(0, 240, 255, 0.5);
            border: 3px solid var(--bg-primary);
        }

        .position-code {
            font-family: 'Orbitron', sans-serif;
            font-size: 32px;
            font-weight: 900;
        }

        .position-key {
            font-size: 12px;
            opacity: 0.8;
            margin-top: 4px;
        }

        .compatible-section {
            margin: 32px 0;
            padding: 24px;
            background: var(--bg-secondary);
            border: 1px solid rgba(0, 240, 255, 0.1);
            border-radius: 20px;
        }

        .section-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: var(--text-secondary);
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .key-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
        }

        .key-tag {
            background: rgba(0, 240, 255, 0.1);
            border: 1px solid rgba(0, 240, 255, 0.3);
            padding: 12px 20px;
            border-radius: 12px;
            font-size: 13px;
            font-weight: 500;
            color: var(--accent-primary);
            transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
            cursor: default;
        }

        .key-tag:hover {
            background: rgba(0, 240, 255, 0.2);
            transform: translateY(-2px);
        }

        .key-tag.perfect {
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            color: var(--bg-primary);
            border-color: transparent;
            font-weight: 700;
        }

        .details-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        .detail-row {
            display: flex;
            justify-content: space-between;
            padding: 12px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            font-size: 12px;
        }

        .detail-label {
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 1px;
            font-size: 10px;
        }

        .detail-value {
            color: var(--accent-primary);
            font-weight: 500;
        }

        .audio-player {
            width: 100%;
            margin-top: 24px;
            border-radius: 12px;
            filter: saturate(0) brightness(0.8) contrast(1.2);
        }

        .debug-panel {
            margin-top: 24px;
            padding: 16px;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(0, 240, 255, 0.1);
            border-radius: 12px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            color: var(--text-secondary);
            max-height: 200px;
            overflow-y: auto;
            line-height: 1.6;
            display: none;
        }

        .debug-panel.active {
            display: block;
        }

        .error {
            background: rgba(255, 0, 85, 0.1);
            border: 1px solid rgba(255, 0, 85, 0.3);
            color: #ff4488;
            padding: 16px;
            border-radius: 12px;
            margin-top: 16px;
            font-size: 13px;
            display: none;
        }

        .error.active {
            display: block;
            animation: fadeInUp 0.4s cubic-bezier(0.16, 1, 0.3, 1);
        }

        @media (max-width: 768px) {
            .logo {
                font-size: 36px;
            }

            .metrics {
                grid-template-columns: 1fr;
            }

            .details-grid {
                grid-template-columns: 1fr;
            }

            .wheel-container {
                width: 280px;
                height: 280px;
            }
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--accent-primary);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent-secondary);
        }
    </style>
</head>
<body>
    <div class="grain"></div>

    <div class="container">
        <header class="header">
            <h1 class="logo">Harmonic</h1>
            <p class="tagline">Professional Audio Analysis - Trance Edition</p>
            <span class="badge">Trance-Optimized Detection (130-145 BPM)</span>
        </header>

        <div class="grid">
            <div class="card control-panel">
                <h2 class="card-title">Live Capture</h2>
                <p style="color: var(--text-secondary); margin-bottom: 24px; font-size: 13px;">
                    Play a track and analyze through your microphone
                </p>

                <div id="recordingControls">
                    <button class="btn" id="startBtn">
                        <span>üé§</span>
                        <span>Start Listening</span>
                    </button>
                    <button class="btn stop" id="stopBtn" style="display: none;">
                        <span>‚èπ</span>
                        <span>Stop & Analyze</span>
                    </button>
                </div>

                <div class="recording-status" id="recordingStatus">
                    <div class="rec-indicator">
                        <div class="rec-dot"></div>
                        <div class="rec-time" id="recordingTime">0:00</div>
                    </div>
                    <p class="rec-hint">Recording ‚Äî 15s minimum for best accuracy</p>
                </div>

                <div class="analyzing" id="analyzing">
                    <div class="spinner"></div>
                    <p class="analyzing-text">Analyzing</p>
                    <p class="analyzing-step" id="analyzingStep">Processing audio...</p>
                </div>

                <div class="error" id="error"></div>
            </div>

            <div class="card results" id="resultsCard">
                <h2 class="card-title">Detection Results</h2>
                
                <div class="metrics">
                    <div class="metric">
                        <div class="metric-label">BPM</div>
                        <div class="metric-value" id="bpmValue">--</div>
                        <div class="metric-sub" id="bpmCandidates"></div>
                        <div class="confidence-bar">
                            <div class="confidence-fill" id="bpmConfidence" style="width: 0%"></div>
                        </div>
                        <div class="confidence-text" id="bpmConfidenceText"></div>
                    </div>
                    
                    <div class="metric">
                        <div class="metric-label">Musical Key</div>
                        <div class="metric-value" id="keyValue" style="font-size: 32px;">--</div>
                        <div class="metric-sub" id="keyCandidates"></div>
                        <div class="confidence-bar">
                            <div class="confidence-fill" id="keyConfidence" style="width: 0%"></div>
                        </div>
                        <div class="confidence-text" id="keyConfidenceText"></div>
                    </div>
                </div>
            </div>
        </div>

        <div class="card results" id="results" style="animation-delay: 0.4s;">
            <div class="camelot-section">
                <h3 class="camelot-title">Camelot Wheel Position</h3>
                <div class="wheel-container">
                    <svg class="wheel-svg" viewBox="0 0 300 300">
                        <g id="outerRing"></g>
                        <g id="innerRing"></g>
                    </svg>
                    <div class="current-position" id="currentPosition">
                        <div class="position-code" id="positionCode">--</div>
                        <div class="position-key" id="positionKey">--</div>
                    </div>
                </div>
            </div>

            <div class="compatible-section">
                <h3 class="section-title">
                    <span>‚ú®</span>
                    <span>Compatible Mixing Keys</span>
                </h3>
                <div class="key-tags" id="compatibleKeys"></div>
            </div>

            <div class="compatible-section">
                <h3 class="section-title">
                    <span>üìä</span>
                    <span>Analysis Details</span>
                </h3>
                <div class="details-grid">
                    <div class="detail-row">
                        <span class="detail-label">Key Method</span>
                        <span class="detail-value" id="keyMethod">--</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">BPM Method</span>
                        <span class="detail-value" id="bpmMethod">--</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">Camelot</span>
                        <span class="detail-value" id="camelotDetail">--</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">Duration</span>
                        <span class="detail-value" id="durationAnalyzed">--</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">Stability</span>
                        <span class="detail-value" id="tempoStability">--</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">Signal Quality</span>
                        <span class="detail-value" id="signalQuality">--</span>
                    </div>
                </div>
            </div>

            <audio id="audioPlayer" class="audio-player" controls></audio>

            <div class="debug-panel" id="debugInfo"></div>
        </div>
    </div>

<script>
    // ============================================
    // HARMONIC ANALYZER PRO - TRANCE EDITION
    // Professional-Grade Key & BPM Detection
    // Optimized for 130-145 BPM Trance
    // ============================================

    // PROFESSIONAL CAMELOT WHEEL MAPPING
    const CAMELOT_WHEEL = {
        'C major': '8B', 'Db major': '3B', 'D major': '10B', 'Eb major': '5B',
        'E major': '12B', 'F major': '7B', 'F# major': '2B', 'Gb major': '2B',
        'G major': '9B', 'Ab major': '4B', 'A major': '11B', 'Bb major': '6B', 'B major': '1B',
        'C minor': '5A', 'C# minor': '12A', 'D minor': '7A', 'D# minor': '2A', 'Eb minor': '2A',
        'E minor': '9A', 'F minor': '4A', 'F# minor': '11A', 'G minor': '6A',
        'G# minor': '1A', 'Ab minor': '1A', 'A minor': '8A', 'A# minor': '3A', 'Bb minor': '3A', 'B minor': '10A'
    };

    const CAMELOT_TO_KEY = Object.fromEntries(
        Object.entries(CAMELOT_WHEEL).map(([key, camelot]) => [camelot, key])
    );

    // Krumhansl-Schmuckler key profiles
    const KEY_PROFILES = {
        major: [6.35, 2.23, 3.48, 2.33, 4.38, 4.09, 2.52, 5.19, 2.39, 3.66, 2.29, 2.88],
        minor: [6.33, 2.68, 3.52, 5.38, 2.60, 3.53, 2.54, 4.75, 3.98, 2.69, 3.34, 3.17]
    };

    const NOTE_NAMES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    const NOTE_NAMES_FLAT = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'];

    let audioContext;
    let mediaRecorder;
    let audioChunks = [];
    let recordingStartTime;
    let recordingInterval;
    let stream;
    let debugLog = [];

    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const recordingStatus = document.getElementById('recordingStatus');
    const recordingTime = document.getElementById('recordingTime');

    startBtn.addEventListener('click', startRecording);
    stopBtn.addEventListener('click', stopRecording);

    function log(msg) {
        debugLog.push(`[${new Date().toLocaleTimeString()}] ${msg}`);
        console.log(msg);
    }

    function showError(message) {
        const errorEl = document.getElementById('error');
        errorEl.textContent = message;
        errorEl.classList.add('active');
    }

    function hideError() {
        const errorEl = document.getElementById('error');
        errorEl.classList.remove('active');
    }

    function showAnalyzing() {
        document.getElementById('analyzing').classList.add('active');
    }

    function hideAnalyzing() {
        document.getElementById('analyzing').classList.remove('active');
    }

    function showResults() {
        document.getElementById('resultsCard').classList.add('active');
        document.getElementById('results').classList.add('active');
    }

    function hideResults() {
        document.getElementById('resultsCard').classList.remove('active');
        document.getElementById('results').classList.remove('active');
    }

    async function startRecording() {
        try {
            debugLog = [];
            hideError();
            hideResults();
            
            stream = await navigator.mediaDevices.getUserMedia({ 
                audio: {
                    echoCancellation: false,
                    noiseSuppression: false,
                    autoGainControl: false,
                    sampleRate: 44100
                } 
            });

            audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 44100 });
            
            mediaRecorder = new MediaRecorder(stream, {
                mimeType: 'audio/webm;codecs=opus',
                audioBitsPerSecond: 128000
            });
            audioChunks = [];

            mediaRecorder.ondataavailable = (event) => {
                audioChunks.push(event.data);
            };

            mediaRecorder.onstop = async () => {
                const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                await processAudio(audioBlob);
            };

            mediaRecorder.start();
            
            startBtn.style.display = 'none';
            stopBtn.style.display = 'inline-flex';
            recordingStatus.classList.add('active');
            
            recordingStartTime = Date.now();
            recordingInterval = setInterval(updateRecordingTime, 100);

        } catch (error) {
            showError('Microphone access denied. Please allow microphone access and try again.');
            console.error('Error accessing microphone:', error);
        }
    }

    function updateRecordingTime() {
        const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
        const minutes = Math.floor(elapsed / 60);
        const seconds = elapsed % 60;
        recordingTime.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }

    function stopRecording() {
        if (mediaRecorder && mediaRecorder.state !== 'inactive') {
            mediaRecorder.stop();
            clearInterval(recordingInterval);
            
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
            }
            
            stopBtn.style.display = 'none';
            startBtn.style.display = 'inline-flex';
            recordingStatus.classList.remove('active');
            showAnalyzing();
        }
    }

    async function processAudio(blob) {
        try {
            updateAnalyzingStep('Decoding audio...');
            const arrayBuffer = await blob.arrayBuffer();
            const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
            
            log(`Audio decoded: ${audioBuffer.duration.toFixed(2)}s, ${audioBuffer.sampleRate}Hz`);

            // Validate audio
            const validation = validateAudio(audioBuffer);
            log(`Audio validation: ${JSON.stringify(validation)}`);

            updateAnalyzingStep('Running TRANCE-OPTIMIZED BPM detection...');
            const bpmResult = await detectBPMPrecision_TranceOptimized(audioBuffer);
            
            updateAnalyzingStep('Analyzing harmonic content for key...');
            const keyResult = await detectKeyPrecision(audioBuffer);
            
            displayResults(bpmResult, keyResult, audioBuffer.duration, validation);
            
            const audioPlayer = document.getElementById('audioPlayer');
            audioPlayer.src = URL.createObjectURL(blob);
            
        } catch (error) {
            showError('Error analyzing audio: ' + error.message);
            console.error('Processing error:', error);
            log(`ERROR: ${error.message}`);
        } finally {
            hideAnalyzing();
            updateDebugPanel();
        }
    }

    function updateAnalyzingStep(text) {
        document.getElementById('analyzingStep').textContent = text;
    }

    function validateAudio(buffer) {
        const duration = buffer.duration;
        const data = buffer.getChannelData(0);
        
        // Calculate RMS
        let sumSquare = 0;
        for (let i = 0; i < data.length; i++) {
            sumSquare += data[i] * data[i];
        }
        const rms = Math.sqrt(sumSquare / data.length);
        
        if (duration < 15) {
            throw new Error('Recording too short (minimum 15s)');
        }
        
        if (rms < 0.01) {
            throw new Error('Recording too quiet - increase volume and try again');
        }
        
        const clipping = rms > 0.95;
        const quality = rms > 0.3 ? 'excellent' : rms > 0.1 ? 'good' : 'fair';
        
        return {
            duration,
            rms: rms.toFixed(3),
            clipping,
            quality
        };
    }

    // ===== TRANCE-OPTIMIZED BPM DETECTION =====
    async function detectBPMPrecision_TranceOptimized(buffer) {
        const sampleRate = buffer.sampleRate;
        const channelData = buffer.getChannelData(0);
        
        log('Starting TRANCE-OPTIMIZED BPM detection (130-145 target)...');
        
        // Step 1: Extract kick-focused onset envelope (40-100 Hz weighted)
        const kickOnsets = extractKickOnsetEnvelope(channelData, sampleRate);
        
        // Step 2: Calculate intervals with trance-specific constraints
        const intervals = calculateInterOnsetIntervals_Trance(kickOnsets, sampleRate);
        log(`Found ${intervals.length} inter-onset intervals`);
        
        // Step 3: Build histogram focusing on 130-145 range
        const histogram = buildBeatHistogram_Constrained(intervals, sampleRate, 120, 160);
        
        // Step 4: Peak picking with trance rules
        const tempoCandidates = findTempoPeaks_Trance(histogram);
        log(`Tempo candidates: ${tempoCandidates.slice(0, 3).map(t => t.bpm.toFixed(1)).join(', ')}`);
        
        // Step 5: Select best with harmonic verification
        const finalBPM = selectBestTempo_Trance(tempoCandidates, intervals);
        const confidence = calculateTempoConfidence_Trance(tempoCandidates, finalBPM, intervals.length);
        const stability = checkTempoStability(intervals, finalBPM);
        
        log(`Final BPM: ${finalBPM}, Confidence: ${confidence.toFixed(1)}%, Stability: ${stability.toFixed(1)}%`);
        
        return {
            bpm: finalBPM,
            confidence: confidence,
            stability: stability,
            method: 'Trance-Optimized Kick Detection',
            candidates: tempoCandidates.slice(0, 5).map(t => t.bpm)
        };
    }

    function extractKickOnsetEnvelope(data, sampleRate) {
        // Filter to focus on low frequencies (kick drum range)
        const filtered = bandpassFilter(data, sampleRate, 40, 100);
        
        const fftSize = 2048;
        const hopSize = 441; // ~10ms
        const numFrames = Math.floor((filtered.length - fftSize) / hopSize);
        
        const envelope = new Float32Array(numFrames);
        let prevEnergy = 0;
        
        for (let i = 0; i < numFrames; i++) {
            const start = i * hopSize;
            const frame = filtered.slice(start, start + fftSize);
            
            // Energy-based onset detection for kicks
            let frameEnergy = 0;
            for (let j = 0; j < frame.length; j++) {
                frameEnergy += frame[j] * frame[j];
            }
            frameEnergy = Math.sqrt(frameEnergy / frame.length);
            
            // Half-wave rectified difference
            const diff = Math.max(0, frameEnergy - prevEnergy * 0.9);
            envelope[i] = diff;
            prevEnergy = frameEnergy;
        }
        
        // Normalize
        const max = Math.max(...envelope);
        if (max > 0) {
            for (let i = 0; i < envelope.length; i++) {
                envelope[i] /= max;
            }
        }
        
        return envelope;
    }

    function calculateInterOnsetIntervals_Trance(envelope, sampleRate) {
        const hopSize = 441;
        const threshold = 0.08;
        const minDistance = Math.floor(0.25 * sampleRate / hopSize);
        
        const peaks = [];
        for (let i = minDistance; i < envelope.length - minDistance; i++) {
            if (envelope[i] > threshold) {
                let isPeak = true;
                for (let j = -minDistance; j <= minDistance; j++) {
                    if (j !== 0 && envelope[i + j] > envelope[i] * 0.99) {
                        isPeak = false;
                        break;
                    }
                }
                if (isPeak) {
                    peaks.push(i);
                }
            }
        }
        
        const intervals = [];
        for (let i = 1; i < peaks.length; i++) {
            const intervalFrames = peaks[i] - peaks[i - 1];
            const intervalSeconds = intervalFrames * hopSize / sampleRate;
            
            const bpm = 60 / intervalSeconds;
            if (bpm >= 100 && bpm <= 160) {
                intervals.push(intervalSeconds);
            }
        }
        
        return intervals;
    }

    function buildBeatHistogram_Constrained(intervals, sampleRate, minBPM, maxBPM) {
        const resolution = 1;
        const numBins = (maxBPM - minBPM) * resolution;
        const histogram = new Float32Array(numBins);
        
        for (const interval of intervals) {
            const bpm = 60 / interval;
            const binIdx = Math.floor((bpm - minBPM) * resolution);
            
            if (binIdx >= 0 && binIdx < numBins) {
                for (let i = -3; i <= 3; i++) {
                    const idx = binIdx + i;
                    if (idx >= 0 && idx < numBins) {
                        const weight = Math.exp(-(i * i) / 2.5);
                        histogram[idx] += weight;
                    }
                }
            }
        }
        
        return histogram;
    }

    function findTempoPeaks_Trance(histogram) {
        const minBPM = 120;
        const peaks = [];
        
        for (let i = 5; i < histogram.length - 5; i++) {
            let isPeak = true;
            let minNeighbor = Infinity;
            
            for (let j = -5; j <= 5; j++) {
                if (j !== 0) {
                    minNeighbor = Math.min(minNeighbor, histogram[i + j]);
                    if (histogram[i + j] >= histogram[i]) {
                        isPeak = false;
                        break;
                    }
                }
            }
            
            if (isPeak && (histogram[i] - minNeighbor) > histogram[i] * 0.1) {
                const bpm = minBPM + i;
                peaks.push({
                    bpm: bpm,
                    strength: histogram[i],
                    prominence: histogram[i] - minNeighbor
                });
            }
        }
        
        peaks.sort((a, b) => b.strength - a.strength);
        return peaks;
    }

    function selectBestTempo_Trance(candidates, intervals) {
        if (candidates.length === 0) return 130;
        
        const primaryRange = candidates.filter(c => c.bpm >= 130 && c.bpm <= 145);
        if (primaryRange.length > 0) {
            return Math.round(primaryRange[0].bpm);
        }
        
        const strongest = candidates[0].bpm;
        
        const doubleTempo = strongest * 2;
        if (doubleTempo >= 130 && doubleTempo <= 145) {
            return Math.round(doubleTempo);
        }
        
        const halfTempo = strongest / 2;
        if (halfTempo >= 130 && halfTempo <= 145) {
            return Math.round(halfTempo);
        }
        
        return Math.round(strongest);
    }

    function calculateTempoConfidence_Trance(candidates, finalBPM, totalIntervals) {
        if (candidates.length === 0) return 0;
        
        let totalStrength = 0;
        let matchingStrength = 0;
        
        for (const candidate of candidates) {
            totalStrength += candidate.strength;
            
            const isClose = Math.abs(candidate.bpm - finalBPM) <= 0.5;
            const isOctave = Math.abs(candidate.bpm - finalBPM * 2) <= 1 ||
                            Math.abs(candidate.bpm - finalBPM / 2) <= 1;
            const isTriple = Math.abs(candidate.bpm - finalBPM * 3) <= 1.5 ||
                            Math.abs(candidate.bpm - finalBPM / 3) <= 0.5;
            
            if (isClose || isOctave || isTriple) {
                matchingStrength += candidate.strength;
            }
        }
        
        const mainPeak = candidates[0].strength;
        const secondPeak = candidates[1]?.strength || 0;
        const prominence = (mainPeak - secondPeak) / mainPeak;
        
        const peakSharpness = Math.exp(-candidates.length / 5);
        const signalQuality = Math.min(1.0, totalIntervals / 50);
        
        const confidenceBase = (matchingStrength / totalStrength) * 100;
        const dominanceFactor = Math.min(1.0, prominence);
        const finalConfidence = confidenceBase * (0.5 + 0.5 * dominanceFactor);
        
        return Math.max(20, Math.min(85, finalConfidence));
    }

    function checkTempoStability(intervals, reportedBPM) {
        const expectedInterval = 60 / reportedBPM;
        
        let variance = 0;
        for (const interval of intervals) {
            variance += Math.pow(interval - expectedInterval, 2);
        }
        variance /= intervals.length;
        
        const stability = Math.max(0, 1 - Math.sqrt(variance) / expectedInterval) * 100;
        return Math.min(100, stability);
    }

    function bandpassFilter(data, sampleRate, lowHz, highHz) {
        const filtered = new Float32Array(data.length);
        
        const a1 = -1.5;
        const a2 = 0.7;
        
        let y1 = 0, y2 = 0;
        
        for (let i = 0; i < data.length; i++) {
            const x = data[i];
            const y = x + a1 * y1 + a2 * y2;
            
            filtered[i] = y;
            y2 = y1;
            y1 = y;
        }
        
        return filtered;
    }

    // ===== PRECISION KEY DETECTION =====
    async function detectKeyPrecision(buffer) {
        const sampleRate = buffer.sampleRate;
        const channelData = buffer.getChannelData(0);
        
        log('Starting precision key detection...');
        
        const chromagram = calculatePrecisionChromagram(channelData, sampleRate);
        log(`Chromagram: ${chromagram.map(v => v.toFixed(3)).join(', ')}`);
        
        const keyResults = applyKSAlgorithm(chromagram);
        
        const finalKey = keyResults[0].key;
        const confidence = Math.min(85, keyResults[0].correlation * 100);
        
        log(`K-S top result: ${finalKey} (${keyResults[0].correlation.toFixed(3)})`);
        
        return {
            key: finalKey,
            confidence: confidence,
            method: 'Krumhansl-Schmuckler + Harmonic Weighting',
            candidates: keyResults.slice(0, 2).map(r => r.key)
        };
    }

    function calculatePrecisionChromagram(data, sampleRate) {
        const chromagram = new Array(12).fill(0);
        const fftSize = 4096;
        const hopSize = fftSize / 4;
        const numAnalyze = Math.min(15, Math.floor((data.length - fftSize) / hopSize));
        
        for (let win = 0; win < numAnalyze; win++) {
            const start = Math.floor(win * (data.length - fftSize) / numAnalyze);
            const segment = data.slice(start, start + fftSize);
            
            // Blackman-Harris window
            const windowed = new Float32Array(fftSize);
            for (let i = 0; i < fftSize; i++) {
                const a0 = 0.35875;
                const a1 = 0.48829;
                const a2 = 0.14128;
                const a3 = 0.01168;
                windowed[i] = segment[i] * (
                    a0 -
                    a1 * Math.cos(2 * Math.PI * i / fftSize) +
                    a2 * Math.cos(4 * Math.PI * i / fftSize) -
                    a3 * Math.cos(6 * Math.PI * i / fftSize)
                );
            }
            
            const pitchClasses = calculatePitchClassesFFT(windowed, sampleRate, fftSize);
            
            for (let i = 0; i < 12; i++) {
                chromagram[i] += pitchClasses[i];
            }
        }
        
        // Normalize
        const sum = chromagram.reduce((a, b) => a + b, 0);
        if (sum > 0) {
            for (let i = 0; i < 12; i++) {
                chromagram[i] /= sum;
            }
        }
        
        // Trance-optimized harmonic weighting
        const weighted = new Array(12).fill(0);
        for (let i = 0; i < 12; i++) {
            weighted[i] += chromagram[i] * 1.2; // Root
            weighted[(i + 7) % 12] += chromagram[i] * 0.8; // Perfect 5th
            weighted[(i + 12) % 12] += chromagram[i] * 0.6; // Octave
            weighted[(i + 3) % 12] += chromagram[i] * 0.3; // Minor 3rd
            weighted[(i + 4) % 12] += chromagram[i] * 0.2; // Major 3rd
        }
        
        const wSum = weighted.reduce((a, b) => a + b, 0);
        if (wSum > 0) {
            for (let i = 0; i < 12; i++) {
                weighted[i] /= wSum;
            }
        }
        
        return weighted;
    }

    function calculatePitchClassesFFT(signal, sampleRate, fftSize) {
        const N = fftSize;
        const pitchClasses = new Array(12).fill(0);
        
        const A4_Hz = 440;
        const A4_midiNote = 69;
        
        const fftMagnitude = computeFFTMagnitude(signal);
        
        for (let pc = 0; pc < 12; pc++) {
            let pcEnergy = 0;
            
            for (let octave = 2; octave <= 8; octave++) {
                const midiNote = pc + (octave * 12);
                const frequencyHz = A4_Hz * Math.pow(2, (midiNote - A4_midiNote) / 12);
                const binIndex = Math.round(frequencyHz / (sampleRate / fftSize));
                
                if (binIndex > 0 && binIndex < fftSize / 2) {
                    pcEnergy += Math.log(1 + Math.abs(fftMagnitude[binIndex]));
                }
            }
            
            pitchClasses[pc] = pcEnergy;
        }
        
        return pitchClasses;
    }

    function computeFFTMagnitude(signal) {
        const N = signal.length;
        const real = new Float32Array(N);
        const imag = new Float32Array(N);
        
        for (let i = 0; i < N; i++) real[i] = signal[i];
        
        // Bit-reversal permutation
        for (let i = 0, j = 0; i < N; i++) {
            if (i < j) {
                [real[i], real[j]] = [real[j], real[i]];
                [imag[i], imag[j]] = [imag[j], imag[i]];
            }
            
            let mask = N >> 1;
            for (; j & mask; mask >>= 1) j &= ~mask;
            j |= mask;
        }
        
        // Cooley-Tukey FFT
        for (let s = 1; s < Math.log2(N); s++) {
            const m = 1 << s;
            const mDiv2 = m >> 1;
            const angleIncrement = -(2 * Math.PI / m);
            
            for (let k = 0; k < N; k += m) {
                let angle = 0;
                
                for (let j = 0; j < mDiv2; j++) {
                    const cosAngle = Math.cos(angle);
                    const sinAngle = Math.sin(angle);
                    
                    const t = k + j + mDiv2;
                    const tr = real[t] * cosAngle - imag[t] * sinAngle;
                    const ti = real[t] * sinAngle + imag[t] * cosAngle;
                    
                    real[t] = real[k + j] - tr;
                    imag[t] = imag[k + j] - ti;
                    
                    real[k + j] += tr;
                    imag[k + j] += ti;
                    
                    angle += angleIncrement;
                }
            }
        }
        
        const magnitude = new Float32Array(N / 2);
        for (let i = 0; i < N / 2; i++) {
            magnitude[i] = Math.sqrt(real[i] * real[i] + imag[i] * imag[i]);
        }
        
        return magnitude;
    }

    function applyKSAlgorithm(chromagram) {
        const results = [];
        
        for (let rootNote = 0; rootNote < 12; rootNote++) {
            for (const [mode, profile] of Object.entries(KEY_PROFILES)) {
                let correlation = 0;
                
                for (let i = 0; i < 12; i++) {
                    const pitchClass = (rootNote + i) % 12;
                    correlation += chromagram[pitchClass] * profile[i];
                }
                
                const keyName = `${NOTE_NAMES[rootNote]} ${mode}`;
                results.push({
                    key: keyName,
                    correlation: correlation,
                    rootNote: rootNote,
                    mode: mode
                });
            }
        }
        
        results.sort((a, b) => b.correlation - a.correlation);
        return results;
    }

    // ===== DISPLAY RESULTS =====
    function displayResults(bpmResult, keyResult, duration, validation) {
        // BPM Results
        document.getElementById('bpmValue').textContent = bpmResult.bpm;
        document.getElementById('bpmConfidence').style.width = bpmResult.confidence + '%';
        document.getElementById('bpmConfidenceText').textContent = `${bpmResult.confidence.toFixed(0)}% confidence`;
        
        if (bpmResult.candidates.length > 1) {
            document.getElementById('bpmCandidates').textContent = `Also: ${bpmResult.candidates.slice(1, 3).map(b => Math.round(b)).join(', ')}`;
        }
        
        // Key Results
        document.getElementById('keyValue').textContent = bpmResult.key || keyResult.key;
        document.getElementById('keyConfidence').style.width = keyResult.confidence + '%';
        document.getElementById('keyConfidenceText').textContent = `${keyResult.confidence.toFixed(0)}% confidence`;
        
        if (keyResult.candidates.length > 1) {
            document.getElementById('keyCandidates').textContent = `Alt: ${keyResult.candidates[1]}`;
        }
        
        // Camelot Wheel
        const camelotCode = CAMELOT_WHEEL[keyResult.key];
        document.getElementById('positionCode').textContent = camelotCode;
        document.getElementById('positionKey').textContent = keyResult.key.split(' ')[0];
        document.getElementById('camelotDetail').textContent = camelotCode;
        
        // Compatible Keys
        const compatible = getCompatibleKeys(camelotCode);
        const compatibleEl = document.getElementById('compatibleKeys');
        compatibleEl.innerHTML = '';
        
        compatible.forEach(code => {
            const keyName = CAMELOT_TO_KEY[code];
            const tag = document.createElement('div');
            tag.className = 'key-tag' + (code === camelotCode ? ' perfect' : '');
            tag.textContent = `${code} - ${keyName}`;
            compatibleEl.appendChild(tag);
        });
        
        // Analysis Details
        document.getElementById('keyMethod').textContent = 'K-S Algorithm';
        document.getElementById('bpmMethod').textContent = 'Trance Kick Detection';
        document.getElementById('durationAnalyzed').textContent = duration.toFixed(1) + 's';
        document.getElementById('tempoStability').textContent = bpmResult.stability.toFixed(0) + '%';
        document.getElementById('signalQuality').textContent = validation.quality.charAt(0).toUpperCase() + validation.quality.slice(1);
        
        showResults();
    }

    function getCompatibleKeys(camelotCode) {
        const compatible = [camelotCode];
        
        const [number, mode] = [parseInt(camelotCode), camelotCode.slice(-1)];
        
        // Same number, different mode
        const otherMode = mode === 'A' ? 'B' : 'A';
        compatible.push(number + otherMode);
        
        // Adjacent numbers, same mode
        const prev = number === 1 ? 12 : number - 1;
        const next = number === 12 ? 1 : number + 1;
        compatible.push(prev + mode);
        compatible.push(next + mode);
        
        // Adjacent numbers, different mode
        compatible.push(prev + otherMode);
        compatible.push(next + otherMode);
        
        return compatible;
    }

    function updateDebugPanel() {
        const debugPanel = document.getElementById('debugInfo');
        debugPanel.textContent = debugLog.join('\n');
        debugPanel.classList.add('active');
    }
</script>
</body>
</html>
